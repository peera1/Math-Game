<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>גיבורי השברים</title>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script> <!-- Added SortableJS -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Assistant:wght@400;700&display=swap');

        body {
            font-family: 'Assistant', sans-serif;
            text-align: center;
            background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
            color: #ecf0f1;
            font-size: 18px;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #game-container {
            width: 90%;
            max-width: 700px; /* Increased max-width for fractions */
            padding: 40px;
            background: rgba(255, 255, 255, 0.95);
            color: #2c3e50;
            border-radius: 25px;
            box-shadow: 0 15px 40px rgba(0,0,0,0.3);
            border: 5px solid #00C4CC; /* Changed border color for fractions theme */
            animation: fadeIn 1s ease-in-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }

        h1 {
            font-size: 48px;
            font-weight: 700;
            color: #1abc9c; /* Greenish-teal for fractions */
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        h1::before, h1::after {
            content: '➗'; /* Fraction symbol */
            color: #2ecc71;
            margin: 0 15px;
        }

        .hidden { display: none !important; } /* Use !important to ensure override */
        
        #progress-container {
            width: 100%;
            background-color: #bdc3c7;
            border-radius: 15px;
            margin: 25px auto;
            height: 30px;
            position: relative;
            overflow: hidden;
            border: 2px solid #95a5a6;
        }

        #progress-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(to right, #2ecc71, #27ae60); /* Green gradient */
            border-radius: 13px;
            text-align: center;
            line-height: 30px;
            color: #2c3e50;
            font-weight: bold;
            transition: width 0.5s ease-in-out;
        }

        #score {
            font-size: 26px;
            color: #3498db;
            margin: 15px 0;
            font-weight: 700;
        }

        #question-number {
            font-size: 22px;
            color: #9b59b6; /* Purple for question number */
        }

        #question-text-for-display { /* Specific style for question instruction text */
            font-size: 24px;
            color: #9b59b6;
            margin-bottom: 20px; /* Space before actual display */
        }

        #question-display {
            display: flex; /* Use flexbox for centering fractions and symbols */
            flex-wrap: wrap; /* Allow wrapping if content is too wide */
            justify-content: center;
            align-items: center;
            font-size: 60px;
            color: #c0392b; /* Reddish for numbers */
            margin: 30px 0;
            font-weight: 700;
            animation: newQuestionPop 0.5s ease;
            min-height: 80px; /* Ensure space even if empty */
        }

        @keyframes newQuestionPop {
            0% { transform: scale(0.5); opacity: 0; }
            80% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }
        
        /* Style for the blank space where the comparison symbol goes */
        #question-display .blank-space {
            display: inline-block;
            width: 70px;
            height: 1.2em;
            vertical-align: middle;
            border-bottom: 4px solid #c0392b;
            margin: 0 10px;
        }

        /* Fraction display styles */
        .fraction-container {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 1em; /* Relative to parent #question-display */
            margin: 0 10px;
            direction: ltr; /* FIX: Force left-to-right ordering of internal elements */
        }
        .whole-part {
            margin-right: 5px;
        }
        .fraction-part {
            display: inline-block;
            text-align: center;
            vertical-align: middle;
        }
        .fraction-numerator {
            display: block;
            border-bottom: 3px solid #c0392b; /* Line for the fraction */
            padding-bottom: 3px;
            margin-bottom: 3px;
            line-height: 1;
        }
        .fraction-denominator {
            display: block;
            line-height: 1;
        }

        /* Comparison buttons */
        #comparison-buttons {
            margin-top: 20px;
            display: flex;
            justify-content: center;
        }
        #comparison-buttons button {
            margin: 0 10px;
            padding: 15px 25px;
            font-size: 28px;
            background: linear-gradient(to bottom, #3498db, #2980b9);
            border: none;
            border-radius: 15px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            border-bottom: 4px solid #206a8f;
        }
        #comparison-buttons button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 15px rgba(0,0,0,0.2);
        }
        #comparison-buttons button:active {
            transform: translateY(1px);
            border-bottom-width: 2px;
        }

        /* Ordering specific styles */
        #ordering-area {
            margin-top: 20px;
            display: flex; /* Flex container for instructions, sortable area, and button */
            flex-direction: column;
            align-items: center;
            gap: 20px; /* Spacing between elements in ordering area */
        }
        #ordering-instructions { /* This will usually be hidden, question-text-for-display used instead */
            font-size: 24px;
            color: #9b59b6;
            margin-bottom: 0; /* Adjusted for gap */
        }

        /* NEW: Wrapper for the 3 drop slots and comparison symbols */
        #ordered-slots-visual-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            margin-bottom: 20px; /* Space between top slots and bottom pool */
            gap: 15px; /* Space between drop slots and symbols */
            direction: ltr; /* Crucial for correct left-to-right visual order */
        }

        /* Styling for individual drop slots */
        .drop-slot {
            flex: 0 0 120px; /* Fixed width, no shrinking/growing, allows 3 to fit */
            height: 80px; /* Height for the drop area */
            border: 2px dotted #3498db; /* Dotted border as in image */
            border-radius: 10px;
            background-color: #eaf6fd; /* Light blue background as in image */
            display: flex; /* Allow dropped item to center */
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
            padding: 5px; /* Internal padding */
            transition: background-color 0.2s, border-color 0.2s;
            /* Ensure dropped item is always LTR within slot */
            direction: ltr;
        }
        .drop-slot:empty {
            /* Style for an empty slot */
            border: 2px dotted #a0d3f2; /* Lighter dotted border for empty state */
            background-color: #f0f8ff; /* Very light blue for empty */
        }
        .drop-slot:hover:empty {
            background-color: #e0f2f7; /* Hover effect on empty slot */
            border-color: #3498db;
        }

        /* Styling for the comparison symbols between slots */
        .comparison-symbol {
            font-size: 40px; /* Larger symbol */
            color: #3498db; /* Blue color */
            font-weight: 700;
            flex-shrink: 0; /* Prevent shrinking */
            pointer-events: none; /* Make sure symbol doesn't interfere with dragging */
            user-select: none; /* Prevent text selection */
        }

        /* NEW: Styles for the bottom fraction pool (source) */
        #fraction-draggable-pool {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            min-height: 100px; /* Height for pool */
            width: 100%;
            border: 2px solid #bdc3c7; /* Pool border */
            border-radius: 10px;
            padding: 15px;
            background-color: #ecf0f1; /* Light background for pool */
            gap: 15px; /* Space between pool items */
            box-sizing: border-box;
        }

        /* Styles for draggable fraction items */
        .draggable-fraction-item {
            background-color: #e0f2f7; /* Light blue */
            border: 2px solid #00C4CC; /* Match game border */
            border-radius: 8px;
            padding: 12px 18px; /* Slightly more padding for touch targets */
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3em; /* Larger for better visibility */
            transition: background-color 0.2s, transform 0.2s;
            min-width: 90px; /* Ensure items have a reasonable width */
            color: #2c3e50; /* Text color */
            box-sizing: border-box; /* Include padding/border in item's size */
        }

        .draggable-fraction-item:hover {
            background-color: #c0e3eb;
            transform: translateY(-2px);
        }

        .draggable-fraction-item.sortable-ghost { /* SortableJS class for placeholder when dragging */
            background-color: #f0f0f0;
            border: 2px dashed #ccc;
            opacity: 0.7;
        }

        /* Styles for fractions inside draggable items - ensures they look good at smaller size */
        .draggable-fraction-item .fraction-container {
            margin: 0; /* Remove extra margin from general .fraction-container */
            font-size: 1em; /* Inherit font size from parent */
            color: #2c3e50; /* Make sure text color is correct */
        }
        .draggable-fraction-item .whole-part {
            margin-right: 5px;
        }
        .draggable-fraction-item .fraction-numerator {
            border-bottom: 2px solid #2c3e50; /* Slightly thinner line, darker color for contrast */
            padding-bottom: 2px;
            margin-bottom: 2px;
        }
        

        button#submit-button { /* General submit button, used for ordering */
            padding: 15px 40px;
            font-size: 20px;
            font-weight: 700;
            background: linear-gradient(to bottom, #e74c3c, #c0392b);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            border-bottom: 4px solid #96281b;
        }

        button#submit-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 15px rgba(0,0,0,0.2);
        }
        
        button#submit-button:active {
            transform: translateY(1px);
            border-bottom-width: 2px;
        }

        #feedback {
            font-size: 22px;
            margin-top: 20px;
            font-weight: 700;
            min-height: 28px;
        }

        #summary {
            animation: summaryAppear 1s ease-out;
        }

        @keyframes summaryAppear {
             from { opacity: 0; transform: translateY(30px); }
             to { opacity: 1; transform: translateY(0); }
        }

        #summary h2 {
            font-size: 40px;
            color: #27ae60;
        }
        
        #summary-table {
            margin: 30px auto;
            border-collapse: collapse;
            width: 100%;
            background: #fff;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        #summary-table th, #summary-table td {
            border: 2px solid #2980b9;
            padding: 15px;
            text-align: center;
        }

        #summary-table th {
            background: linear-gradient(to right, #3498db, #2980b9);
            color: white;
            font-size: 20px;
        }

        #summary-table td {
            font-size: 18px;
            color: #2c3e50;
        }

        #summary-table tr:nth-child(even) {
            background-color: #ecf0f1;
        }
        
        #summary-message {
            font-size: 22px;
            color: #2c3e50;
            margin: 30px 0;
            line-height: 1.7;
            background: #e8f8f5;
            padding: 20px;
            border-radius: 15px;
            border: 3px dashed #1abc9c;
        }

        @keyframes shake {
            0% { transform: translateX(0); }
            20% { transform: translateX(-10px); }
            40% { transform: translateX(10px); }
            60% { transform: translateX(-10px); }
            80% { transform: translateX(10px); }
            100% { transform: translateX(0); }
        }

        /* Mobile specific adjustments */
        @media (max-width: 600px) {
            #game-container {
                padding: 20px;
            }
            h1 {
                font-size: 36px;
            }
            #question-text-for-display {
                font-size: 20px;
            }
            #ordered-slots-visual-wrapper {
                flex-wrap: nowrap; /* Keep on one line if possible */
                gap: 5px; /* Smaller gap */
            }
            .drop-slot {
                flex: 1 1 auto; /* Allow slots to be more flexible */
                min-width: 80px; /* Adjust min width for smaller screens */
                height: 70px; /* Adjust height */
            }
            .comparison-symbol {
                font-size: 30px;
                margin: 0 5px;
            }
            #fraction-draggable-pool {
                padding: 10px;
                gap: 10px;
                min-height: 80px;
            }
            .draggable-fraction-item {
                font-size: 1.1em;
                padding: 8px 12px;
                min-width: 70px;
            }
            button#submit-button {
                padding: 12px 30px;
                font-size: 18px;
            }
        }
    </style>
</head>

<body>
    <div id="game-container">
        <h1>גיבורי השברים</h1>
        
        <div id="game-area">
            <div id="progress-container">
                <div id="progress-bar">0%</div>
            </div>
            <p id="score">ניקוד: 0</p>
            <p id="question-number"></p>
            
            <p id="question-text-for-display"></p> <!-- New element for question text -->
            <div id="question-display"></div> <!-- This will hold fractions for comparison -->

            <div id="comparison-buttons" class="hidden">
                <button class="comparison-btn" onclick="checkComparisonAnswer('<')"><i class="fas fa-less-than"></i></button>
                <button class="comparison-btn" onclick="checkComparisonAnswer('=')"><i class="fas fa-equals"></i></button>
                <button class="comparison-btn" onclick="checkComparisonAnswer('>')"><i class="fas fa-greater-than"></i></button>
            </div>

            <div id="ordering-area" class="hidden">
                <!-- TOP: The area where fractions should be dropped and ordered -->
                <div id="ordered-slots-visual-wrapper">
                    <!-- Drop slots and comparison symbols will be dynamically inserted here -->
                </div>
                
                <!-- BOTTOM: The pool of fractions to be dragged -->
                <div id="fraction-draggable-pool">
                    <!-- Shuffled draggable-fraction-item elements will be rendered here -->
                </div>
            </div>
            
            <button id="submit-button" onclick="checkAnswer()">שחרר את הכוח!</button>
            <p id="feedback"></p>
        </div>

        <div id="summary" class="hidden">
            <h2>משימה הושלמה, את/ה גיבור/ת על!</h2>
            <table id="summary-table">
                <thead>
                    <tr><th>שאלה</th><th>האתגר</th><th>תשובתך</th><th>תקינות</th><th>זמן (שניות)</th></tr>
                </thead>
                <tbody id="summary-body"></tbody>
            </table>
            <div id="summary-message">
                כל הכבוד על המאמץ וההשקעה! השלמת את משימת השברים כמו גיבור/ה אמיתי/ת. תזכור/י תמיד, כל תרגיל שאת/ה פותר/ת מחזק את "שריר המוח" והופך את כוח העל שלך במתמטיקה לחזק עוד יותר! אבא ואמא גאים בך מאוד על הנחישות והרצון להצליח!
            </div>
        </div>
    </div>

    <script>
        // Helper for Greatest Common Divisor
        function gcd(a, b) {
            if (b === 0) return a;
            return gcd(b, a % b);
        }

        // Fraction Class: Represents a fraction and handles its logic (simplify, convert to decimal/string)
        class Fraction {
            constructor(numerator, denominator, whole = 0) {
                if (denominator === 0) {
                    throw new Error("Denominator cannot be zero.");
                }
                // Ensure denominator is always positive (for positive fractions only as per requirement)
                if (denominator < 0) { 
                    numerator *= -1;
                    denominator *= -1;
                }

                // Convert mixed to improper for internal consistency during construction
                let totalNumerator = numerator;
                if (whole !== 0) {
                    // For positive fractions, simply add whole to numerator (W N/D -> (W*D+N)/D)
                    totalNumerator = whole * denominator + numerator;
                }

                this.numerator = totalNumerator;
                this.denominator = denominator;
                this.simplify(); // Simplify immediately after construction
            }

            simplify() {
                if (this.numerator === 0) {
                    this.denominator = 1; // 0/1 for 0
                    return this;
                }
                const common = gcd(Math.abs(this.numerator), this.denominator);
                this.numerator /= common;
                this.denominator /= common;
                return this;
            }

            toDecimal() {
                return this.numerator / this.denominator;
            }

            // NEW: Method to decide how to display the fraction string
            toDisplayString() {
                if (this.numerator === 0) return "0";
                
                let absNumerator = Math.abs(this.numerator); // All fractions are positive
                const whole = Math.floor(absNumerator / this.denominator);
                const remainder = absNumerator % this.denominator;
                
                if (remainder === 0) { // It's a pure whole number (e.g., 6/2 -> 3)
                    return `${whole}`;
                }
                
                if (absNumerator < this.denominator) { // It's a proper fraction (e.g., 1/2)
                    return `${absNumerator}/${this.denominator}`;
                } else { // It's an improper fraction (e.g., 7/2, 5/3)
                    // Randomly decide to show as improper (N/D) or mixed (W N/D)
                    if (getRandomInt(0, 1) === 0) { // 50% chance for improper N/D display
                        return `${absNumerator}/${this.denominator}`; // e.g., 7/2
                    } else { // 50% chance for mixed W N/D display
                        return `${whole} ${remainder}/${this.denominator}`; // e.g., 3 1/2
                    }
                }
            }

            // Original toMixedString (now used for canonical summary output if needed)
            // It provides a consistent mixed number/proper fraction format for validation and summary
            toMixedString() { 
                if (this.numerator === 0) return "0";
                const absNumerator = Math.abs(this.numerator);
                const whole = Math.floor(absNumerator / this.denominator);
                const remainder = absNumerator % this.denominator;
                if (remainder === 0) return `${whole}`;
                if (whole === 0) return `${remainder}/${this.denominator}`;
                return `${whole} ${remainder}/${this.denominator}`;
            }


            toString() { // For internal debugging or simple representation
                return `${this.numerator}/${this.denominator}`;
            }

            // Static method to parse a string like "1/2", "3", "1 1/2" into a Fraction object
            static parse(fractionString) {
                fractionString = fractionString.trim();
                if (!fractionString) throw new Error("Empty fraction string.");

                if (fractionString.includes(' ')) { // Mixed number (e.g., "1 1/2")
                    const parts = fractionString.split(' ');
                    let whole = parseInt(parts[0]);
                    const fracParts = parts[1].split('/');
                    let num = parseInt(fracParts[0]);
                    let den = parseInt(fracParts[1]);
                    if (num >= den) {
                        const newWhole = whole + Math.floor(num / den);
                        const newNum = num % den;
                        return new Fraction(newNum, den, newWhole);
                    }
                    return new Fraction(num, den, whole);
                } else if (fractionString.includes('/')) { // Simple or improper fraction (e.g., "3/4" or "7/2")
                    const parts = fractionString.split('/');
                    let num = parseInt(parts[0]);
                    let den = parseInt(parts[1]);
                    return new Fraction(num, den);
                } else { // Pure whole number (e.g., "5") - if somehow still generated or parsed
                    let whole = parseInt(fractionString);
                    return new Fraction(0, 1, whole); 
                }
            }
        }


        // Function to render a Fraction object into its HTML display elements
        function renderFraction(fraction, containerElement) {
            containerElement.innerHTML = ''; // Clear previous content

            const displayString = fraction.toDisplayString(); // Get the dynamically formatted string
            
            let currentWholePart = '';
            let currentNumerator = '';
            let currentDenominator = '';

            // Regex to parse mixed number strings like "W N/D", "N/D", or "W" or "N/D" (improper)
            const mixedNumberRegex = /^(\d+)\s(\d+)\/(\d+)$/; // e.g., "4 2/5"
            const simpleOrImproperFractionRegex = /^(\d+)\/(\d+)$/; // e.g., "2/5" or "7/2"
            const wholeNumberRegex = /^(\d+)$/; // e.g., "4"

            let match;

            if ((match = displayString.match(mixedNumberRegex))) {
                currentWholePart = match[1];
                currentNumerator = match[2];
                currentDenominator = match[3];
            } else if ((match = displayString.match(simpleOrImproperFractionRegex))) {
                currentNumerator = match[1];
                currentDenominator = match[2];
            } else if ((match = displayString.match(wholeNumberRegex))) {
                currentWholePart = match[1];
            }
            
            // Render whole part
            if (currentWholePart && currentWholePart !== "0") { 
                const wholeSpan = document.createElement('span');
                wholeSpan.className = 'whole-part';
                wholeSpan.textContent = currentWholePart;
                containerElement.appendChild(wholeSpan);
            }
            
            // Render fractional part
            if (currentNumerator && currentDenominator) {
                const fracPartDiv = document.createElement('div');
                fracPartDiv.className = 'fraction-part';

                const numSpan = document.createElement('span');
                numSpan.className = 'fraction-numerator';
                numSpan.textContent = currentNumerator;
                fracPartDiv.appendChild(numSpan);

                const denSpan = document.createElement('span');
                denSpan.className = 'fraction-denominator';
                denSpan.textContent = currentDenominator;
                fracPartDiv.appendChild(denSpan);

                containerElement.appendChild(fracPartDiv);
            } else if (currentWholePart === "0" && !currentNumerator && !currentDenominator) { // Explicitly handle pure 0
                 const wholeSpan = document.createElement('span');
                 wholeSpan.className = 'whole-part';
                 wholeSpan.textContent = "0";
                 containerElement.appendChild(wholeSpan);
            }
        }


        // Global game state variables
        const NUM_OF_QUESTIONS = 10;
        let questions = [];
        let currentQuestionIndex = 0;
        let score = 0;
        let questionDetails = [];
        let startTime;
        let sortablePoolInstance = null; // To store SortableJS instance for the pool
        let sortableTargetInstances = []; // To store SortableJS instance for the target slots (now an array)

        // Constants for fraction generation limits
        const MAX_DENOMINATOR = 12;
        const MAX_NUMERATOR_FOR_IMPROPER = 25; // Max numerator value for improper fractions (e.g., 25/7)
        const MAX_WHOLE_FOR_MIXED = 5; // Max whole part for mixed numbers (e.g., 5 1/2)

        // Function to get a random integer within a range
        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // Function to generate a single random positive fraction (NO PURE WHOLE NUMBERS)
        function generateRandomFraction() {
            let denominator = getRandomInt(2, MAX_DENOMINATOR);
            let numerator;
            let whole = 0;

            const fractionVarietyType = getRandomInt(1, 3); // 1: Proper, 2: Improper, 3: Mixed

            if (fractionVarietyType === 1) { // Proper fraction (e.g., 1/2, 3/4)
                numerator = getRandomInt(1, denominator - 1);
            } else if (fractionVarietyType === 2) { // Improper fraction (e.g., 5/3, 7/2)
                // Ensure numerator is truly greater than denominator for improper
                numerator = getRandomInt(denominator + 1, MAX_NUMERATOR_FOR_IMPROPER);
            } else { // Mixed number (e.g., 1 1/2, 2 3/4)
                whole = getRandomInt(1, MAX_WHOLE_FOR_MIXED);
                // Ensure numerator for mixed part is always proper (N < D)
                numerator = getRandomInt(1, denominator - 1); 
            }
            
            // Ensure result is not 0 (which can happen if numerator is 0 initially)
            if (numerator === 0 && whole === 0) { // If it tried to make 0/X
                numerator = getRandomInt(1, denominator - 1); // Force it to be a proper fraction
            }

            // All fractions are positive, as per requirement
            return new Fraction(numerator, denominator, whole);
        }

        // Generates a comparison question (f1 ___ f2)
        function generateComparisonQuestion() {
            let f1, f2;
            let type = getRandomInt(1, 3); // 1: same den, 2: same num, 3: general fractions

            // Helper to generate a fraction ensuring it's not a pure whole number
            const getNonWholeFraction = () => {
                let frac;
                let attempts = 0;
                do {
                    frac = generateRandomFraction();
                    attempts++;
                } while (frac.remainder === 0 && attempts < 10); // Re-generate if it simplifies to a whole number
                
                if (frac.remainder === 0) { // If still a whole number after attempts, force a simple proper fraction
                    return new Fraction(1, getRandomInt(2, MAX_DENOMINATOR));
                }
                return frac;
            };

            f1 = getNonWholeFraction();
            f2 = getNonWholeFraction();

            // Ensure fractions are not trivially identical for comparison
            let attempts = 0;
            while (f1.toDecimal() === f2.toDecimal() && attempts < 10) { 
                f2 = getNonWholeFraction();
                attempts++;
            }
            if (f1.toDecimal() === f2.toDecimal()) { // If still equal after many attempts, force them to be different
                f2 = new Fraction(f2.numerator + 1, f2.denominator); // Smallest possible change
            }


            let correctSymbol;
            if (f1.toDecimal() < f2.toDecimal()) correctSymbol = "<";
            else if (f1.toDecimal() > f2.toDecimal()) correctSymbol = ">";
            else correctSymbol = "=";

            const questionText = `איזה סימן מתאים בין השברים?`;

            return {
                type: 'comparison',
                questionText: questionText,
                displayFractions: [f1, f2], // Store Fraction objects for rendering
                correctAnswer: correctSymbol,
                f1: f1, // Store actual Fraction objects for summary or re-evaluation
                f2: f2
            };
        }

        // Generates an ordering question (always 3 fractions)
        function generateOrderingQuestion() {
            const numFractions = 3; 
            let fractions = [];
            let decimalValues = new Set(); 

            // Helper to generate a fraction ensuring it's not a pure whole number
            const getNonWholeFraction = () => {
                let frac;
                let attempts = 0;
                do {
                    frac = generateRandomFraction();
                    attempts++;
                } while (frac.remainder === 0 && attempts < 10); // Re-generate if it simplifies to a whole number
                
                if (frac.remainder === 0) { // If still a whole number after attempts, force a simple proper fraction
                    return new Fraction(1, getRandomInt(2, MAX_DENOMINATOR));
                }
                return frac;
            };

            while (fractions.length < numFractions) {
                let newF = getNonWholeFraction(); 
                let decimal = newF.toDecimal();
                // Ensure decimal value is not too close to another to avoid ambiguity
                let isTooClose = false;
                for (let val of decimalValues) {
                    if (Math.abs(decimal - val) < 0.05) { // Threshold for "too close"
                        isTooClose = true;
                        break;
                    }
                }
                if (!decimalValues.has(decimal) && !isTooClose) {
                    fractions.push(newF);
                    decimalValues.add(decimal);
                }
            }

            // Sort the fractions by their decimal value to get the correct order
            fractions.sort((a, b) => a.toDecimal() - b.toDecimal());

            const correctOrderStrings = fractions.map(f => f.toDisplayString()); // Use toDisplayString for summary's correct answer representation
            const displayFractionsShuffled = [...fractions].sort(() => Math.random() - 0.5); // Shuffle actual Fraction objects for display

            const questionText = `סדרו את השברים הבאים מהקטן לגדול:`;

            return {
                type: 'ordering',
                questionText: questionText,
                displayFractions: displayFractionsShuffled, // Shuffled Fraction objects for presentation (these go into the pool)
                correctAnswer: correctOrderStrings.join(', '), // For summary
                actualSortedFractions: fractions // Store actual sorted Fraction objects for validation
            };
        }


        // Main question generation for the game
        function generateGameQuestion() {
            const questionType = getRandomInt(1, 2); // 1: comparison, 2: ordering
            if (questionType === 1) {
                return generateComparisonQuestion();
            } else {
                return generateOrderingQuestion();
            }
        }


        // Game flow functions
        function startGame() {
            questions = [];
            currentQuestionIndex = 0;
            score = 0;
            questionDetails = [];
            document.getElementById("score").innerText = `ניקוד: 0`;
            document.getElementById("game-area").classList.remove("hidden");
            document.getElementById("summary").classList.add("hidden");

            for (let i = 0; i < NUM_OF_QUESTIONS; i++) {
                let newQ;
                let isUnique = false;
                let attempts = 0;
                while (!isUnique && attempts < 50) { 
                    newQ = generateGameQuestion();
                    // For uniqueness check, use the consistent toMixedString format
                    const newQDisplayStrings = newQ.displayFractions.map(f => typeof f === 'object' ? f.toMixedString() : f); 
                    const isDuplicate = questions.some(q => 
                        q.type === newQ.type && 
                        JSON.stringify(q.displayFractions.map(f => typeof f === 'object' ? f.toMixedString() : f)) === JSON.stringify(newQDisplayStrings)
                    );

                    if (!isDuplicate) {
                        isUnique = true;
                    }
                    attempts++;
                    if (attempts >= 50 && !isUnique) { 
                        console.warn("Could not generate a unique question after many attempts.");
                        isUnique = true;
                    }
                }
                questions.push(newQ);
            }
            updateProgress();
            nextQuestion();
        }

        // Create confetti effect
        function createConfetti() {
            if (typeof confetti === 'function') {
                confetti({
                    particleCount: 150,
                    spread: 90,
                    origin: { y: 0.6 },
                    colors: ['#2ecc71', '#3498db', '#9b59b6', '#ffffff'],
                    shapes: ['star', 'circle']
                });
            }
        }

        // Display the next question
        function nextQuestion() {
            if (currentQuestionIndex >= questions.length) {
                showSummary();
                return;
            }

            const currentQ = questions[currentQuestionIndex];
            
            // Reset question display animation
            document.getElementById("question-display").style.animation = 'none';
            void document.getElementById("question-display").offsetWidth; 
            document.getElementById("question-display").style.animation = 'newQuestionPop 0.5s ease';

            document.getElementById("question-number").innerText = `משימה ${currentQuestionIndex + 1} מתוך ${NUM_OF_QUESTIONS}`;
            document.getElementById("feedback").innerText = "";
            document.getElementById("question-display").innerHTML = ''; // Clear comparison fraction content
            document.getElementById("question-text-for-display").innerHTML = ''; // Clear question instruction text

            // *** Ensure all interactive elements are hidden by default for a clean slate ***
            document.getElementById("comparison-buttons").classList.add("hidden");
            document.getElementById("ordering-area").classList.add("hidden");
            document.getElementById("submit-button").classList.add("hidden"); 

            // Destroy previous SortableJS instances if they exist
            if (sortablePoolInstance) {
                sortablePoolInstance.destroy();
                sortablePoolInstance = null;
            }
            if (sortableTargetInstances.length > 0) { // Check if it's an array with instances
                sortableTargetInstances.forEach(instance => instance.destroy());
                sortableTargetInstances = []; // Reset the array
            }


            startTime = new Date();

            if (currentQ.type === 'comparison') {
                document.getElementById("question-text-for-display").textContent = currentQ.questionText;
                
                const frac1Container = document.createElement('div');
                frac1Container.className = 'fraction-container';
                renderFraction(currentQ.f1, frac1Container); // Pass Fraction object directly
                document.getElementById("question-display").appendChild(frac1Container);

                const blankSpace = document.createElement('span');
                blankSpace.className = 'blank-space'; // Visual placeholder for the symbol
                document.getElementById("question-display").appendChild(blankSpace);

                const frac2Container = document.createElement('div');
                frac2Container.className = 'fraction-container';
                renderFraction(currentQ.f2, frac2Container); // Pass Fraction object directly
                document.getElementById("question-display").appendChild(frac2Container);

                document.getElementById("comparison-buttons").classList.remove("hidden");
                // For comparison questions, buttons handle submission, general submit button remains hidden.
            } else if (currentQ.type === 'ordering') {
                document.getElementById("question-text-for-display").textContent = currentQ.questionText;
                
                const orderedSlotsVisualWrapper = document.getElementById('ordered-slots-visual-wrapper');
                orderedSlotsVisualWrapper.innerHTML = ''; // Clear previous content

                const fractionPool = document.getElementById('fraction-draggable-pool');
                fractionPool.innerHTML = ''; // Clear source pool

                const numSlots = currentQ.actualSortedFractions.length; // Will be 3
                let dropSlotElements = []; // To hold references to the actual droppable div elements

                for (let i = 0; i < numSlots; i++) {
                    const slot = document.createElement('div');
                    slot.className = 'drop-slot';
                    slot.id = `drop-slot-${i}`; // Unique ID for each slot
                    orderedSlotsVisualWrapper.appendChild(slot);
                    dropSlotElements.push(slot);

                    if (i < numSlots - 1) { // Add '<' symbol between slots
                        const symbol = document.createElement('span');
                        symbol.className = 'comparison-symbol';
                        symbol.textContent = '<';
                        orderedSlotsVisualWrapper.appendChild(symbol);
                    }
                }
                
                currentQ.displayFractions.forEach(f => { // displayFractions is already shuffled (Fraction objects)
                    const draggableItem = document.createElement('div');
                    draggableItem.className = 'draggable-fraction-item';
                    draggableItem.setAttribute('data-fraction-decimal', f.toDecimal());
                    draggableItem.setAttribute('data-fraction-string', f.toDisplayString()); // Use toDisplayString for draggable item string

                    const fContainer = document.createElement('div');
                    fContainer.className = 'fraction-container';
                    renderFraction(f, fContainer); // Pass Fraction object directly
                    draggableItem.appendChild(fContainer);
                    fractionPool.appendChild(draggableItem); // Items start in the pool
                });

                // Initialize SortableJS for the pool (source)
                sortablePoolInstance = Sortable.create(fractionPool, {
                    group: {
                        name: 'fractions',
                        pull: 'clone', // Items are cloned from the pool
                        put: false
                    },
                    animation: 150,
                    sort: false, // Items in the pool are not internally sortable
                    ghostClass: 'sortable-ghost'
                });

                // Initialize SortableJS for each drop slot (target)
                sortableTargetInstances = []; // Reset array
                dropSlotElements.forEach(slot => {
                    sortableTargetInstances.push(Sortable.create(slot, {
                        group: {
                            name: 'fractions',
                            pull: true, // Allow pulling out from a slot (e.g., to move to another slot or back to pool)
                            put: true,   // Allow putting into this slot
                        },
                        animation: 150,
                        sort: false, // No internal sorting WITHIN a single slot (as it should only contain one item)
                        ghostClass: 'sortable-ghost',
                        onMove: function (evt, originalEvent) {
                            // Prevents dropping into a slot if it already contains an item
                            // This ensures each slot holds max 1 item.
                            return evt.related.children.length === 0;
                        }
                    }));
                });

                document.getElementById("ordering-area").classList.remove("hidden");
                document.getElementById("submit-button").classList.remove("hidden"); // Show general submit for ordering
            }
        }

        // Handle comparison question answer
        function checkComparisonAnswer(userSymbol) {
            const currentQ = questions[currentQuestionIndex];
            const isCorrect = (userSymbol === currentQ.correctAnswer); // Direct comparison
            const endTime = new Date();
            const timeTaken = Math.round((endTime - startTime) / 1000);

            questionDetails.push({
                type: 'comparison',
                questionText: `${currentQ.f1.toDisplayString()} ___ ${currentQ.f2.toDisplayString()}`, // Use toDisplayString for summary
                userAnswer: userSymbol,
                correctAnswer: currentQ.correctAnswer,
                isCorrect: isCorrect,
                time: timeTaken
            });

            if (isCorrect) {
                score += 10 + (timeTaken < 10 ? 5 : 0);
                document.getElementById("score").innerText = `ניקוד: ${score}`;
                createConfetti();
                document.getElementById("feedback").innerText = "מעולה! התשובה שלך מתאימה!";
                document.getElementById("feedback").style.color = "#27ae60";
                
                currentQuestionIndex++;
                updateProgress();
                setTimeout(nextQuestion, 1500);
            } else {
                document.getElementById("feedback").innerText = `לא בדיוק... התשובה הנכונה הייתה: ${currentQ.correctAnswer}`;
                document.getElementById("feedback").style.color = "#c0392b";
            }
        }

        // Handle ordering question answer
        function checkOrderingAnswer() {
            const currentQ = questions[currentQuestionIndex];
            const dropSlotElements = [
                document.getElementById('drop-slot-0'),
                document.getElementById('drop-slot-1'),
                document.getElementById('drop-slot-2')
            ];

            let userAnswerDecimals = [];
            let userAnswerStrings = [];
            let allSlotsFilled = true;

            dropSlotElements.forEach(slot => {
                if (slot.children.length === 1) { // Each slot must have exactly one child
                    const item = slot.children[0];
                    userAnswerDecimals.push(parseFloat(item.getAttribute('data-fraction-decimal')));
                    userAnswerStrings.push(item.getAttribute('data-fraction-string'));
                } else {
                    allSlotsFilled = false;
                }
            });

            // Check if all slots have exactly one item
            if (!allSlotsFilled) {
                document.getElementById("feedback").innerText = `לא בדיוק... אנא גרור/י שבר אחד לכל אחת משלוש הקופסאות למעלה.`;
                document.getElementById("feedback").style.color = "#c0392b";
                dropSlotElements.forEach(slot => {
                    if (slot.children.length === 0) { // Shake only empty slots
                        slot.style.animation = 'shake 0.5s';
                        setTimeout(() => slot.style.animation = '', 500);
                    }
                });
                return;
            }

            let isCorrect = true;
            for (let i = 0; i < currentQ.actualSortedFractions.length; i++) {
                // Compare with a small tolerance for floating point numbers
                if (Math.abs(userAnswerDecimals[i] - currentQ.actualSortedFractions[i].toDecimal()) > 0.0001) {
                    isCorrect = false;
                    break;
                }
            }
            
            const endTime = new Date();
            const timeTaken = Math.round((endTime - startTime) / 1000);

            questionDetails.push({
                type: 'ordering',
                questionText: `סדר את: ${currentQ.displayFractions.map(f => f.toDisplayString()).join(', ')}`, // Use toDisplayString for summary
                userAnswer: userAnswerStrings.join(', '),
                correctAnswer: currentQ.correctAnswer, // This is already using toDisplayString
                isCorrect: isCorrect,
                time: timeTaken
            });

            if (isCorrect) {
                score += 10 + (timeTaken < 15 ? 5 : 0); // Ordering takes longer, higher bonus threshold
                document.getElementById("score").innerText = `ניקוד: ${score}`;
                createConfetti();
                document.getElementById("feedback").innerText = "מצוין! הסדר נכון!";
                document.getElementById("feedback").style.color = "#27ae60";
                
                currentQuestionIndex++;
                updateProgress();
                setTimeout(nextQuestion, 1500);
            } else {
                document.getElementById("feedback").innerText = `לא בדיוק... הסדר הנכונה היה: ${currentQ.correctAnswer}. נסה/י שוב!`;
                document.getElementById("feedback").style.color = "#c0392b";
                dropSlotElements.forEach(slot => { // Shake all filled slots on incorrect answer
                    if (slot.children.length === 1) {
                        slot.children[0].style.animation = 'shake 0.5s'; // Shake the item itself
                        setTimeout(() => slot.children[0].style.animation = '', 500);
                    }
                });
            }
        }
        
        // This function is called by the main "submit-button". It will delegate based on question type.
        function checkAnswer() {
            const currentQ = questions[currentQuestionIndex];
            if (currentQ && currentQ.type === 'ordering') {
                checkOrderingAnswer();
            } else {
                document.getElementById("feedback").innerText = "אנא בחר/י סימן השוואה, גיבור/ה!";
                document.getElementById("feedback").style.color = "#e74c3c";
            }
        }


        // Update progress bar
        function updateProgress() {
            let progress = (currentQuestionIndex / NUM_OF_QUESTIONS) * 100;
            document.getElementById("progress-bar").style.width = progress + "%";
            document.getElementById("progress-bar").innerText = Math.round(progress) + "%";
        }

        // Show game summary
        function showSummary() {
            document.getElementById("game-area").classList.add("hidden");
            
            let summaryBody = document.getElementById("summary-body");
            summaryBody.innerHTML = "";
            questionDetails.forEach((detail, i) => {
                const correctnessEmoji = detail.isCorrect ? '✅' : '❌';
                let row = `<tr><td>${i + 1}</td><td>${detail.questionText}</td><td>${detail.userAnswer}</td><td>${correctnessEmoji}</td><td>${detail.time}</td></tr>`;
                summaryBody.innerHTML += row;
            });
            document.getElementById("summary").classList.remove("hidden");
            updateProgress(); // Ensure progress bar is full at the end

            // Final confetti burst for summary
            const duration = 5 * 1000;
            const animationEnd = Date.now() + duration;
            const defaults = { startVelocity: 30, spread: 360, ticks: 60, zIndex: 0 };
            function randomInRange(min, max) { return Math.random() * (max - min) + min; }
            const interval = setInterval(function() {
              const timeLeft = animationEnd - Date.now();
              if (timeLeft <= 0) return clearInterval(interval);
              const particleCount = 50 * (timeLeft / duration);
              confetti(Object.assign({}, defaults, { particleCount, origin: { x: randomInRange(0.1, 0.3), y: Math.random() - 0.2 }, colors: ['#2ecc71', '#3498db'] }));
              confetti(Object.assign({}, defaults, { particleCount, origin: { x: randomInRange(0.7, 0.9), y: Math.random() - 0.2 }, colors: ['#9b59b6', '#ffffff'] }));
            }, 250);
        }

        document.addEventListener('DOMContentLoaded', startGame);
    </script>
</body>
</html>
